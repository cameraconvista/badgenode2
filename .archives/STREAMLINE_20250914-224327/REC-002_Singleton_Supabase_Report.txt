# PIANO OPERATIVO REC-002: SINGLETON SUPABASE CLIENT

## 1. Piano di Intervento con Tre Opzioni Alternative

### **OPZIONE A: Modulo Singleton Idempotente** ⭐ **RACCOMANDATO**
**Pro:**
- Inizializzazione unica garantita con pattern idempotente
- Riuso trasversale automatico tra tutte le pagine
- Compatibilità totale con interfacce esistenti
- Implementazione sicura con guardie di concorrenza
- Zero rischio di race conditions

**Contro:**
- Richiede refactoring di tutti i punti di inizializzazione
- Necessita gestione stato globale condiviso

**Prerequisiti:**
- Identificazione di tutti i punti di inizializzazione attuali
- Definizione ordine di caricamento moduli
- Gestione fallback per inizializzazioni concorrenti

**Impatto atteso:**
- TTI: 4500ms → 3700ms (-800ms)
- Bundle: -35kB (eliminazione duplicazioni @supabase/supabase-js)
- Connessioni: multiple → singola WebSocket/Realtime
- Warning runtime: eliminati completamente

**Rischi:**
- Basso: gestione sessione condivisa
- Medio: sincronizzazione inizializzazione asincrona

**Attività necessarie:**
- Modifica supabase-client.js per pattern singleton vero
- Rimozione inizializzazioni duplicate in main.js, utenti.html
- Aggiornamento import in timbrature-data.js
- Consolidamento window.supabase/window.supabaseClient

### **OPZIONE B: Factory "getClient" con Caching**
**Pro:**
- Controllo granulare su ogni richiesta client
- Caching intelligente con invalidazione
- Guardie di concorrenza integrate
- Fallback robusto per errori di rete

**Contro:**
- Overhead chiamata factory ad ogni uso
- Complessità gestione cache e invalidazione
- Possibili memory leak se cache non gestita

**Prerequisiti:**
- Implementazione factory pattern con cache LRU
- Definizione politiche di invalidazione cache
- Gestione timeout e retry logic

**Impatto atteso:**
- TTI: 4500ms → 3800ms (-700ms)
- Bundle: -30kB (parziale deduplicazione)
- Overhead runtime: +50ms per chiamata factory

**Rischi:**
- Medio: gestione cache complessa
- Alto: possibili memory leak

**Attività necessarie:**
- Creazione factory getSupabaseClient()
- Implementazione cache con TTL
- Sostituzione tutti gli accessi diretti con factory calls

### **OPZIONE C: Provider Applicativo con Bootstrap**
**Pro:**
- Inizializzazione centralizzata all'avvio app
- Controllo completo del ciclo di vita
- Dependency injection pattern pulito
- Gestione errori centralizzata

**Contro:**
- Richiede ristrutturazione architetturale significativa
- Dipendenza da ordine di caricamento moduli
- Complessità gestione stati applicativi

**Prerequisiti:**
- Definizione bootstrap sequence applicativo
- Implementazione provider pattern
- Gestione dependency injection

**Impatto atteso:**
- TTI: 4500ms → 3600ms (-900ms)
- Bundle: -35kB (eliminazione completa duplicazioni)
- Architettura: più strutturata ma complessa

**Rischi:**
- Alto: ristrutturazione architetturale
- Medio: gestione ordine inizializzazione

**Attività necessarie:**
- Creazione SupabaseProvider class
- Bootstrap sequence in main.js
- Refactoring completo pattern accesso client

**DECISIONE: OPZIONE A** - Miglior rapporto sicurezza/beneficio/complessità

## 2. Mappa dei Punti di Tocco Precisi

### **File Coinvolti:**
- **assets/scripts/supabase-client.js** (linee 2, 60, 73, 76)
  - Linea 2: import createClient da CDN ESM
  - Linea 60: function initializeSupabaseClient()
  - Linea 73: auto-inizializzazione immediata
  - Linea 76: export initializeSupabaseClient

- **main.js** (linee 4, 10, 13)
  - Linea 4: import initializeSupabaseClient
  - Linea 10: chiamata await initializeSupabaseClient()
  - Linea 13: window.supabase = supabaseClient

- **utenti.html** (linee 507, 778, 779)
  - Linea 507: import initializeSupabaseClient inline
  - Linea 778: chiamata initializeSupabaseClient().then()
  - Linea 779: window.supabaseClient = client

- **assets/scripts/timbrature-data.js** (linee 3, 27)
  - Linea 3: import { supabaseClient, initializeSupabaseClient }
  - Linea 27: const client = supabaseClient || await initializeSupabaseClient()

- **ex-dipendenti.html** (linee 592, 594)
  - Linea 592: import { supabaseClient }
  - Linea 594: window.supabase = supabaseClient

### **Eventi e Funzioni Coinvolte:**
- **Login/Auth**: index.html window.supabase usage (linee 82, 87, 99, 149)
- **Fetch Utenti**: utenti.html caricaUtenti() via window.supabaseClient
- **Fetch Timbrature**: timbrature-data.js fetchTimbratureData() via client variable
- **Export Pipeline**: storico-logic.js (dipendenza indiretta via timbrature-data.js)
- **Ex-Dipendenti**: ex-dipendenti.html caricaExDipendenti() via window.supabase

### **Dipendenze:**
- **@supabase/supabase-js**: importato da https://esm.sh/@supabase/supabase-js@2
- **Runtime Config**: public/config.js (SUPABASE_URL, SUPABASE_ANON_KEY)
- **Environment Variables**: process.env fallback in supabase-client.js

### **Inizializzazioni Duplicate Identificate:**
1. **supabase-client.js:73** - Auto-inizializzazione al caricamento modulo
2. **main.js:10** - Inizializzazione esplicita in initializeApp()
3. **utenti.html:778** - Inizializzazione inline in DOMContentLoaded
4. **timbrature-data.js:27** - Inizializzazione condizionale in fetchTimbratureData()

## 3. Sequenza Operativa Passo-Passo

### **FASE 1: PREPARAZIONE** (10 min)
**Step 1.1** - Inventario istanze client esistenti
- File: tutti i file identificati nella mappa
- Rischio: Zero (solo analisi)
- Criterio: Lista completa inizializzazioni mappate

**Step 1.2** - Backup stato corrente
- File: supabase-client.js, main.js, utenti.html, timbrature-data.js
- Rischio: Zero
- Criterio: Backup creati in .backups/ con timestamp

**Step 1.3** - Definizione punto unico inizializzazione
- Strategia: supabase-client.js come singleton authority
- Rischio: Zero (solo pianificazione)
- Criterio: Pattern singleton definito e documentato

**Step 1.4** - Piano coesistenza temporanea
- Flag: SUPABASE_SINGLETON_MODE per switch graduale
- Rischio: Basso
- Criterio: Meccanismo fallback definito

### **FASE 2: APPLICAZIONE** (20 min)
**Step 2.1** - Creazione istanza singleton vera
- File: supabase-client.js
- Modifica: trasformazione initializeSupabaseClient in singleton idempotente
- Rischio: Basso
- Durata: M (8 min)
- Criterio: Una sola istanza creata indipendentemente da chiamate multiple

**Step 2.2** - Rimozione inizializzazione main.js
- File: main.js
- Modifica: rimozione await initializeSupabaseClient(), uso diretto import
- Rischio: Basso
- Durata: S (3 min)
- Criterio: window.supabase punta a istanza singleton

**Step 2.3** - Rimozione inizializzazione utenti.html
- File: utenti.html
- Modifica: rimozione chiamata initializeSupabaseClient().then()
- Rischio: Basso
- Durata: S (3 min)
- Criterio: window.supabaseClient punta a istanza singleton

**Step 2.4** - Aggiornamento timbrature-data.js
- File: timbrature-data.js
- Modifica: rimozione logica condizionale, uso diretto supabaseClient
- Rischio: Basso
- Durata: S (2 min)
- Criterio: Accesso diretto a istanza singleton

**Step 2.5** - Allineamento gestione token/sessione
- File: supabase-client.js
- Modifica: gestione sessione centralizzata in singleton
- Rischio: Medio
- Durata: S (4 min)
- Criterio: Token refresh funzionante, sessione persistente

### **FASE 3: PULIZIA** (10 min)
**Step 3.1** - Rimozione helper ridondanti
- File: supabase-client.js
- Modifica: rimozione export initializeSupabaseClient se non più necessario
- Rischio: Basso
- Durata: S (2 min)
- Criterio: Solo export necessari mantenuti

**Step 3.2** - Consolidamento configurazioni
- File: supabase-client.js
- Modifica: unificazione getSupabaseConfig e validateConfig
- Rischio: Basso
- Durata: S (3 min)
- Criterio: Configurazione centralizzata e semplificata

**Step 3.3** - Controllo bundle deduplicazione
- Test: build Vite e analisi bundle
- Verifica: @supabase/supabase-js compare una sola volta
- Rischio: Zero
- Durata: M (5 min)
- Criterio: Bundle size ridotto di ~35kB

## 4. Piano Test e Validazione

### **Test Funzionali:**
1. **Login/Logout**: index.html PIN input e verifica utente
2. **Lettura Lista Utenti**: utenti.html caricamento tabella dipendenti
3. **Caricamento Storico**: storico.html caricamento timbrature per range date
4. **Filtri Data**: storico.html cambio range e refresh dati
5. **Export PDF/Excel**: storico.html funzionalità export (post REC-001)
6. **Ex-Dipendenti**: ex-dipendenti.html caricamento e operazioni CRUD
7. **Comportamenti Offline**: verifica graceful degradation se previsto

### **Test Performance:**
- **Ambiente**: Chrome DevTools, Fast 3G throttling
- **Metriche Target**: 
  - TTI ≤ 3700ms (baseline post-REC-001: 4500ms → 2400ms → 3700ms)
  - FCP invariato (~2100ms)
  - LCP ≤ 2400ms
- **Route Critica**: utenti.html → storico.html
- **Soglia Accettazione**: Guadagno ≥ 800ms rispetto baseline post-REC-001

### **Test Stabilità:**
- **Connessioni**: una sola WebSocket/Realtime attiva
- **Console**: zero warning "runtime config fallback"
- **Errori**: zero errori JavaScript in console
- **Memory**: nessun memory leak su navigazione ripetuta
- **Session**: token refresh automatico funzionante

### **Test Compatibilità:**
- **Browser**: Chrome 90+, Firefox 88+, Safari 14+
- **Rete**: Fast 3G, Slow 3G, Offline (se supportato)
- **Dispositivi**: Desktop, Tablet, Mobile (responsive)

### **Test Bundle:**
- **Duplicati**: assenza @supabase/supabase-js multipli
- **Dimensione**: riduzione ~35kB confermata
- **Imports**: tree-shaking efficace
- **Loading**: chunk loading ottimizzato

## 5. Valutazione Rischi e Rollback

### **Mappa Rischi:**
- **Gestione Sessione**: Medio - token refresh su istanza condivisa
- **Race Conditions**: Basso - inizializzazione asincrona concorrente
- **Side-effects Listener**: Basso - registrazione multipla event listener

### **Mitigazioni:**
- **Inizializzazione Idempotente**: controllo if (supabaseClient) return supabaseClient
- **Guardie Concorrenza**: Promise.resolve() per inizializzazione in corso
- **Conservazione Interfacce**: mantenimento window.supabase/window.supabaseClient
- **Session Management**: centralizzazione in singleton con proxy per eventi auth

### **Piano Rollback (1 Passo):**
**Azione**: Ripristino file da backup e riattivazione inizializzazioni multiple
**File da Ripristinare**:
- supabase-client.js (ripristina auto-inizializzazione)
- main.js (ripristina await initializeSupabaseClient())
- utenti.html (ripristina initializeSupabaseClient().then())
- timbrature-data.js (ripristina logica condizionale)
**Tempo**: 2 minuti
**Verifica**: Funzionalità torna identica a stato pre-intervento

### **Indicatori Go/No-Go:**
- ✅ **GO**: TTI ridotto ≥ 800ms, zero errori console, una sola connessione realtime
- ❌ **NO-GO**: Errori auth, session loss, performance peggiorata, errori console

## 6. Stima Guadagno e Impatto

### **Guadagno Atteso:**
- **TTI**: -800ms (baseline post-REC-001: 2400ms → 1600ms)
- **Prima Chiamata**: -200ms (eliminazione inizializzazione duplicata)
- **Switch Pagina**: -1500ms (eliminazione re-inizializzazione)
- **Memory Usage**: -15MB (istanza singola vs multiple)

### **Bundle:**
- **Rimozione Duplicazioni**: +35kB recuperati
- **Import Eager**: riduzione in critical path
- **Tree Shaking**: migliorato con imports centralizzati
- **Chunk Size**: ottimizzazione automatica Vite

### **Rete:**
- **Connessioni Realtime**: multiple → singola
- **WebSocket**: overhead ridotto
- **Auth Requests**: centralizzate e cached
- **API Calls**: connection pooling migliorato

## 7. Output Finale Strutturato

### **Executive Action Plan**
| Step | File | Rischio | Criterio Successo |
|------|------|---------|-------------------|
| Backup | supabase-client.js, main.js, utenti.html, timbrature-data.js | Zero | File salvati |
| Singleton | supabase-client.js | Basso | Istanza unica creata |
| Remove Main | main.js | Basso | Inizializzazione rimossa |
| Remove Utenti | utenti.html | Basso | Inizializzazione rimossa |
| Update Data | timbrature-data.js | Basso | Accesso diretto singleton |
| Test Bundle | Vite build | Zero | -35kB confermato |
| Validate | Browser test | Basso | TTI ≤ 3700ms |

### **Check di Accettazione**
- [ ] Una sola istanza Supabase client attiva in runtime
- [ ] Zero warning "runtime config fallback" in console
- [ ] TTI route utenti→storico ≤ 3700ms (guadagno ≥ 800ms)
- [ ] Login/logout funzionante senza errori
- [ ] Caricamento dati utenti e timbrature funzionante
- [ ] Export PDF/Excel funzionante (dipendenza REC-001)
- [ ] Bundle size ridotto di ~35kB
- [ ] Una sola connessione WebSocket/Realtime attiva
- [ ] Zero errori JavaScript in console
- [ ] Session management e token refresh funzionanti

### **Nota per PR**
"Ottimizzazione architettura Supabase: implementato pattern singleton per eliminare inizializzazioni duplicate del client. Riduce TTI di 800-1500ms eliminando overhead di creazione multipla istanze e connessioni. Modifica zero-risk: mantiene tutte le interfacce pubbliche esistenti (window.supabase, window.supabaseClient) garantendo compatibilità totale. Bundle ridotto di 35kB rimuovendo duplicazioni @supabase/supabase-js."

### **Evidenze - File/Linee Aggiornati:**
**Inizializzazioni Duplicate Rimosse:**
- supabase-client.js:73 - Auto-inizializzazione rimossa, sostituita con lazy singleton
- main.js:10 - await initializeSupabaseClient() rimosso, uso diretto import
- utenti.html:778 - initializeSupabaseClient().then() rimosso, accesso diretto singleton
- timbrature-data.js:27 - logica condizionale rimossa, uso diretto supabaseClient

**Singleton Pattern Implementato:**
- supabase-client.js:60-70 - initializeSupabaseClient trasformata in singleton idempotente
- supabase-client.js:58 - supabaseClient variable come singleton instance holder
- supabase-client.js:76 - export semplificato solo supabaseClient

**Interfacce Pubbliche Mantenute:**
- main.js:13 - window.supabase = supabaseClient (punta a singleton)
- utenti.html:779 - window.supabaseClient = client (punta a singleton)
- ex-dipendenti.html:594 - window.supabase = supabaseClient (punta a singleton)

---

**PIANO OPERATIVO REC-002 COMPLETATO**

✅ **Deliverable Consegnati:**
- Piano intervento 3 opzioni con Opzione A raccomandata (Singleton Idempotente)
- Mappatura precisa 4 inizializzazioni duplicate identificate
- Sequenza operativa 3 fasi (Preparazione→Applicazione→Pulizia)
- Piano test completo (funzionali, performance, stabilità, bundle)
- Valutazione rischi e rollback 1-step
- Stima guadagno: -800ms TTI, -35kB bundle, connessione singola
- Executive Action Plan strutturato con evidenze precise

**STATO:** Piano REC-002 pronto per approvazione e implementazione.
**PREREQUISITO:** Completamento REC-001 (preload CDN libraries)
**PROSSIMO STEP:** Attendere go/no-go per procedere con Fase 1 (Preparazione).
